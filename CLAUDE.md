# 开发工作流程与规范

## 核心原则(⭐必读)

```plaintext
🎯 理解用户核心意图:
   优先深度理解用户问题的本质需求,而非字面意思。
   通过代码分析确认用户真实意图,避免理解偏差。
   ⚠️ 不理解用户修改意图时,必须先询问澄清,再执行修改。

💬 修改意图必须写入注释(⭐强制要求):
   每次代码修改必须在注释中写明"为什么要这样修改"。
   注释应说明:修改背景、解决的问题、设计考虑。
   防止未来AI不了解背景而错误修改代码。

🔍 深度代码分析:
   - 定位相关代码位置,理解现有实现机制
   - 识别设计模式和资源管理方式
   - 分析代码调用链和数据流转
   - 评估修改的影响范围和风险

📊 影响分析优先:
   - 分析修改可能影响的模块和功能
   - 评估代码修改的风险点
   - 识别潜在的兼容性和数据安全问题
   - 提供清晰的修改方案说明

✅ 设计方案必须包含:
   - 对用户需求的理解和解读
   - 代码分析和现有实现的理解
   - 影响分析和风险评估
   - 等待用户明确同意后再执行
```

## 一、开发工作流程

### 1. 需求理解阶段

#### 1.1 必须执行的步骤

```plaintext
1. 深度理解用户意图(⭐核心)
   - 解读用户问题的本质需求
   - 识别用户要解决的核心问题
   - 确认用户期望的修改方式(直接修改/新建/扩展)
   - 理解用户对代码修改范围的期望

2. 代码分析
   - 定位相关代码位置和文件
   - 理解现有实现逻辑和机制
   - 识别设计模式和代码结构
   - 分析代码调用链和数据流转

3. 影响范围分析
   - 识别可能受影响的模块和功能
   - 分析修改对其他代码的依赖关系
   - 评估修改的复杂度和风险

4. 项目上下文理解
   - 阅读 README.md 了解项目背景
   - 阅读 项目索引.md 清晰项目结构
   - 查看相关流程文档理解业务逻辑
```

#### 1.2 用户意图解读原则(⭐重要)

```plaintext
优先理解用户的核心意图,而非字面意思:

🔍 意图分析:
   - 用户说"修改XX功能" → 分析是要改现有方法还是新建功能
   - 用户说"优化XX逻辑" → 确认是要重构还是微调
   - 用户说"新增XX" → 明确是要新建文件还是扩展现有类

✅ 确认方式:
   1. 通过代码分析确认用户可能的意图
   2. 理解用户描述的真实目的
   3. 如有歧义,主动询问澄清
   4. 基于代码实际情况给出建议

🎯 目标:真正理解用户想要达到的效果,给出最合适的实现方案
```

#### 1.3 需求确认原则

```plaintext
✅ 核心意图理解:深度理解用户要解决的本质问题
✅ 方案合理性:基于代码分析提供合适的实现方案
✅ 主动分析:主动进行代码分析和影响评估
✅ 主动澄清:不确定时主动询问,避免自行臆断
✅ 灵活应对:根据实际情况选择最合适的实现方式
```

### 2. 方案设计阶段

#### 2.1 代码分析(⭐优先执行)

```plaintext
在设计方案前,先进行代码分析:

🔍 代码理解:
   1. 定位相关代码文件和位置
   2. 理解现有实现逻辑和机制
   3. 识别设计模式和代码结构
   4. 分析代码调用链和数据流转

📊 影响评估:
   1. 分析修改可能影响的模块和功能
   2. 评估对其他代码的依赖关系
   3. 识别潜在的兼容性问题
   4. 评估性能和安全性影响

💡 实现方式分析:
   - 基于代码分析判断最合适的实现方式
   - 考虑用户意图和代码实际情况
   - 提供灵活的实现建议(直接修改/新建/扩展)
```

#### 2.2 设计输出要求

代码修改方案以简洁为主,说明改动位置和原因。
无需写出完整代码,指出文件、行数、方法、修改内容即可。

在编写代码前,必须输出:

```markdown
## 修改方案

### 1. 用户需求理解
[解读用户要解决的核心问题,理解用户的真实意图]

### 2. 代码分析(⭐必填)
- 相关代码位置:位于`XX文件`的`XX方法`(第XX行)
- 现有实现机制:[简要说明现有逻辑]
- 设计模式识别:[如有]使用了XX设计模式
- 调用关系分析:[说明方法如何被调用,数据如何流转]

### 3. 修改方案
- `path/to/file1.java`:修改`XX方法`(第XX行),[具体修改内容]
- `path/to/file2.java`:[新增/修改/删除]`XX方法`,[具体操作]

### 4. 核心逻辑
1. 步骤一:[操作目的],[具体操作],[操作结果]
2. 步骤二:[操作目的],[具体操作],[操作结果]

### 5. 影响分析(⭐重点)
- ✅ 不影响:XX 功能、XX 模块
- ⚠️ 可能影响:XX 功能(需要测试验证)
- 🔧 需要配合修改:XX 配置、XX 文档
- 📊 影响范围评估:[详细说明影响的模块和功能]

### 6. 风险评估
- 性能影响:[无/轻微/需优化]
- 数据安全:[无风险/需注意 XX]
- 兼容性:[完全兼容/需要 XX 调整]
- 代码一致性:[是否符合现有风格]
```

#### 2.2 获得用户确认

```plaintext
⚠️ 重要:必须获得用户明确同意后才能执行修改
```

### 3. 代码实现阶段

#### 3.1 编码规范检查清单

```plaintext
⭐ 代码质量(通用要求):
☑️ 函数职责单一,逻辑清晰
☑️ 变量命名清晰,见名知意
☑️ 关键逻辑添加注释说明,解释为什么这样做
☑️ 异常处理完善,不吞异常
☑️ 日志记录关键节点和数据,便于调试
☑️ 资源使用后正确释放
☑️ 并发安全,避免竞态条件
☑️ 修改代码,注释说明同步更新

✅ 代码风格:
☑️ 遵循项目现有的代码风格(命名、缩进、格式)
☑️ 保持与现有代码的一致性
☑️ 合理组织代码结构
```

#### 3.2 代码质量标准

```plaintext
✅ 注释要求:
   - 函数文档字符串完整(包含参数、返回值说明)
   - 关键逻辑添加注释,解释为什么这样做
   - 复杂算法或业务逻辑需详细说明
   - 修改代码时同步更新相关注释

✅ 错误处理:
   - 参数验证完善,提前返回错误
   - 关键步骤记录日志(开始、成功、失败)
   - 异常分类捕获,不吞异常
   - 资源使用后正确释放(在finally块中)
```

#### 3.3 修改意图注释规范(⭐强制要求)

```plaintext
⚠️ 核心原则:每次代码修改必须在注释中写明修改意图

📝 注释内容必须包含:
   1. 修改背景:为什么需要修改?(用户需求、BUG修复、性能优化等)
   2. 解决的问题:这次修改解决了什么具体问题?
   3. 设计考虑:为什么选择这种实现方式?有什么替代方案?
   4. 注意事项:后续修改时需要注意什么?

📍 注释位置规范:
   ✅ 方法级修改:在方法文档注释中添加【修改说明】
   ✅ 代码块修改:在修改的代码块前添加行注释
   ✅ 重要逻辑:在关键代码行添加内联注释

📋 注释格式示例:

   # 方法级修改示例 (Java)
   /**
    * 下载PDF文件
    * 
    * 【修改说明 - 2025-11-16】
    * 修改背景:用户反馈下载超时导致任务失败
    * 解决问题:增加超时时间从30秒改为60秒,并添加重试机制
    * 设计考虑:选择指数退避重试策略,避免频繁重试造成服务器压力
    * 注意事项:后续如需修改超时时间,需同时考虑Redis队列超时配置
    */
   public void downloadFile(String url) {
       // 实现代码...
   }

   # 代码块修改示例 (Python)
   # 【修改说明 - 2025-11-16】
   # 修改背景:AI误认为需要创建新的浏览器池,实际应该复用现有实例
   # 解决问题:改为从全局池中获取浏览器,避免重复创建导致资源泄露
   # 设计考虑:使用对象池模式,通过borrowObject()获取而非new创建
   # 注意事项:使用完毕后必须调用returnObject()归还到池中
   browser = browser_pool.borrowObject()
   try:
       # 使用浏览器...
   finally:
       browser_pool.returnObject(browser)

   # 关键逻辑修改示例
   if retry_count > 3:  # 从5改为3 - 用户要求减少重试次数以加快失败任务处理
       return False

⚠️ AI执行要求:
   1. 不理解用户修改意图时,必须先询问用户澄清
   2. 确认理解意图后,在代码注释中完整记录修改说明
   3. 注释使用中文,表达清晰,便于未来理解
   4. 避免模糊注释(如"优化代码"、"修复BUG"),必须说明具体内容

❌ 错误示例:
   # 优化代码 (太模糊,未说明为什么要优化)
   # 修改逻辑 (未说明修改了什么,为什么要修改)
   # BUG修复 (未说明是什么BUG,如何修复的)

✅ 正确示例:
   # 【修改说明】用户要求减少内存占用,将批量大小从1000改为100
   # 【修改说明】修复并发场景下的竞态条件,添加synchronized同步锁
   # 【修改说明】根据用户反馈,将超时时间从30秒调整为60秒
```

#### 3.3 完成后输出要求

```plaintext
✅ 必须输出:修改完成后立即输出简单总结(口头总结,不保存文档)
✅ 总结格式(通用):
   - 修改内容:列出修改的文件和主要变更点(3-5行)
   - 关键变更:突出最重要的改动(1-2句话)
   - 影响范围:说明影响的功能模块
✅ 总结原则:简洁明了,突出重点,不超过10行
❌ 严格禁止:主动创建或保存任何形式的详细总结文档
❌ 严格禁止:询问用户是否需要保存文档(直接不保存)
```

**简单总结格式:** 修改内容(3-5行)、关键变更(1-2句)、影响范围
**重要提醒:** 只在响应中输出总结,不要创建、保存或询问是否保存文档

### 4. 测试验证阶段

#### 4.1 测试要求

```plaintext
✅ 必须测试:每次修改完成后必须进行测试
✅ 测试覆盖:正常流程 + 边界情况 + 异常情况
✅ 日志检查:验证日志输出是否完整清晰
✅ 性能验证:检查是否存在性能瓶颈
✅ 清理测试代码:测试完成后删除所有测试代码
```

#### 4.2 测试脚本规范

- 测试脚本放在项目根目录或 test/ 目录
- 文件名格式:test_<功能名>.py
- 包含测试用例:正常流程、边界情况、异常情况
- 使用 assert 断言验证结果
- 输出清晰的测试结果

### 5. 文档更新阶段

#### 5.1 文档更新原则

```plaintext
✅ 代码注释:直接更新,无需询问
✅ 内联文档:函数文档字符串、类说明等,直接更新
✅ README.md:功能变更时可以直接更新(仅限必要的功能说明)
✅ 项目索引.md:架构，技术，设计，模块，类名，包结构等项目结构等相关变更时可以直接更新
❌ 严格禁止:创建任何形式的总结文档、变更日志文档、分析报告等
❌ 严格禁止:询问用户是否需要保存文档
```

#### 5.2 允许直接更新的内容

```plaintext
只有以下内容可以直接更新:

1. 代码内注释
   - 函数文档字符串
   - 类说明注释
   - 关键逻辑注释
   - 修改意图说明注释

2. README.md (仅必要时)
   - 新增功能的说明
   - API 接口变更
   - 配置项变更
   - 重要注意事项

⚠️ 重要提醒:
   - 不创建新的文档文件(如:优化总结.md、变更日志.md等)
   - 不保存详细的任务总结到文件
   - 完成任务后只在对话中输出简单总结即可
```

## 二、文档编写规范

### 1. README.md 结构

严格遵循原本文档结构进行更新
严格禁止改动原本文档结构


### 2. 文档更新原则

```plaintext
✅ 及时更新:每次修改后立即更新相关文档
✅ 详细准确:确保文档与代码实现一致
✅ 突出变更:在文档中明确标注修改内容
✅ 保留历史:重要变更记录在更新日志中
✅ 简单精要:日志简洁但是能够突出重点
```

#### 3.1 文档变更标注方式

在更新的章节标题后添加【更新日期】标记,并说明:

- 修改内容:增加/修改/删除了什么
- 修改原因:为什么要修改
- 操作说明:具体操作步骤的四要素(目的、来源、操作、结果)

## 三、任务执行检查清单

在开始任何开发任务前,请确认:

### 1. 理解阶段

- ⭐ 已深度理解用户核心意图和真实需求
- ⭐ 不理解修改意图时,已主动询问用户澄清
- ☑️ 已阅读 README.md,理解项目背景
- ☑️ 已阅读相关流程文档,理解业务逻辑
- ⭐ 已定位相关代码位置,理解现有实现
- ⭐ 已分析代码调用链和数据流转
- ⭐ 已识别设计模式和代码结构
- ⭐ 已评估修改的影响范围和风险
- ☑️ 已明确用户需求,无歧义

### 2. 设计阶段

- ⭐ 已完成代码分析,理解现有实现机制
- ⭐ 已完成影响评估,识别风险和依赖关系
- ☑️ 已输出修改方案,包含目标、代码分析、文件、逻辑、影响
- ☑️ 已评估风险,包含性能、安全、兼容性、代码一致性
- ☑️ 已获得用户明确同意

### 3. 实现阶段

- ☑️ 代码职责单一,逻辑清晰
- ⭐ 已在代码注释中写明修改意图(包含背景、问题、设计考虑、注意事项)
- ☑️ 关键逻辑添加注释说明
- ☑️ 日志记录完善,便于调试
- ☑️ 异常处理完善，统一化风格
- ☑️ 遵循现有代码风格和命名规范

### 4. 测试阶段

- ☑️ 已测试正常流程
- ☑️ 已测试边界情况
- ☑️ 已测试异常情况
- ☑️ 已验证日志输出
- ☑️ 已删除测试代码

### 5. 文档阶段

- ☑️ 已输出简单总结(修改内容、关键变更、影响范围)
- ☑️ 已更新代码注释和文档字符串
- ☑️ 已更新 README.md(如有必要)
- ☑️ 已更新 项目索引.md(如有必要)
- ❌ 不要创建任何总结文档或分析报告文件

## 四、特殊要求

### 1. 策略禁止修改

```plaintext
❌ 禁止:添加用户未要求的核心策略(如:关键词变体搜索)
❌ 禁止:改变用户指定的业务逻辑流程
❌ 禁止:擅自修改核心算法和数据结构

✅ 允许:优化实现细节(日志、异常处理、性能优化)
✅ 允许:增强代码健壮性(参数验证、边界检查)
✅ 允许:改进代码可维护性(重构、解耦、注释)
```

### 2. 主动性要求

```plaintext
⭐ 主动代码分析(最重要):
   - 主动定位相关代码位置,理解现有实现
   - 主动分析代码调用链和数据流转
   - 主动识别设计模式和代码结构
   - 主动评估修改的影响范围和风险
   - 发现用户描述与代码实现不符时,主动澄清

⭐ 主动理解用户意图:
   - 深度解读用户问题的本质需求
   - 分析用户期望的修改方式
   - 基于代码实际情况给出建议
   - 不确定时主动询问澄清

✅ 主动质量保障:
   - 主动测试:不等用户要求,修改后主动测试
   - 主动优化:发现可优化点主动提出建议
   - 主动总结:修改完成后主动输出简单总结(仅在对话中输出,不保存文档)
   - 主动同步:修改后主动同步修改注释

❌ 严格禁止:创建或保存任何形式的总结文档
```

## 五、最佳实践原则

### 1. 代码分析与理解(⭐优先级最高)

#### 1.1 深入理解代码实现

```plaintext
通过代码分析理解真实实现机制,而非依赖字面描述:

🔍 分析步骤:
   - 定位代码位置,阅读完整实现
   - 追踪调用链,理解数据流转
   - 识别设计模式和代码结构
   - 分析资源管理和生命周期

💡 理解示例:
   - "创建池子" → 分析代码实际是borrowObject()还是new()
   - "获取配置" → 确认是getInstance()还是直接new
   - "修改逻辑" → 理解现有实现,判断修改方式
```

#### 1.2 识别设计模式

```plaintext
识别代码中的设计模式有助于理解实现机制:

🎯 对象池模式(Pool Pattern):
   识别特征:xxxPool、borrowObject、returnObject
   
🎯 单例模式(Singleton Pattern):
   识别特征:getInstance、getBean、静态实例
   
🎯 工厂模式(Factory Pattern):
   识别特征:createXxx、buildXxx、newInstance
   
🎯 策略模式(Strategy Pattern):
   识别特征:多个实现类、Map映射、switch分支
```

#### 1.3 代码分析思维流程

```plaintext
每次设计方案前,按以下顺序思考:

1️⃣ 代码分析阶段:
   - 定位相关代码位置
   - 理解现有实现逻辑
   - 分析代码调用关系
   - 识别设计模式

2️⃣ 影响评估阶段:
   - 分析修改影响的模块
   - 评估对其他代码的依赖
   - 识别潜在风险点
   - 评估性能和安全性

3️⃣ 方案设计阶段:
   - 基于代码分析设计方案
   - 考虑用户意图和实际情况
   - 选择最合适的实现方式
   - 提供清晰的修改说明

4️⃣ 实现阶段:
   - 保持代码风格一致性
   - 添加必要的注释说明
   - 完善错误处理和日志
   - 同步更新相关文档
```

### 2. 扁平化复杂判断逻辑

- 使用早期返回(Early Return)代替多层嵌套
- 每个条件判断后立即返回,避免嵌套超过2层
- 在判断失败时记录日志说明原因

### 3. 使用策略模式替代多重判断

- 将多个 if-else 分支封装为独立的处理方法
- 使用字典映射状态与处理方法的关系
- 便于扩展新状态,符合开闭原则

### 4. 完善的日志记录

- 任务开始记录关键参数
- 每个步骤开始和完成都记录日志
- 记录关键数据(文件大小、耗时、URL等)
- 异常捕获时记录详细错误信息
- 资源清理操作也要记录日志

---